%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

FILE *myfile = NULL;

#define YY_INPUT(buf, result, max_size)                \
        {                                              \
          int yyc= fgetc(myfile);                      \
          result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1); \
        }


//#define YY_DEBUG

#define YY_STACK_SIZE 3000

#define YY_MEMORIZATION

typedef struct _value {
  int type;
  int size;
  int serial;
  union {
    char *string;
    int integer;
    struct _value **expression;
  } body;
} *value;

#define YYSTYPE value

#define SNULL 0
#define SINTEGER 1
#define SSTRING 2
#define SSYMBOL 3
#define SEXPRESSION 4

void validate_value(value a);
void print_value(value a);
value mk_symbol(char *string);

static value parse_result = NULL;

static int serialNumber = 0;

struct _value_list {
  value v;
  struct _value_list* next;
};

static struct _value_list *value_list = NULL;

value
new_value()
{
  value v = malloc(sizeof(struct _value));
  struct _value_list *new_link = malloc(sizeof(struct _value_list));
  
/*  {
    struct _value_list *n = value_list;
    while(n != NULL) {
      validate_value(n->v);
      n = n->next;
    }
  }
*/

  v->body.expression = NULL;
  v->body.string = NULL;
  v->size = 0;
  v->serial = serialNumber++;

  new_link->next = value_list;
  new_link->v = v;
  value_list = new_link;

  return v;
}

void
free_values()
{
  value v;
  struct _value_list *l;
  while(value_list != NULL) {
    v = value_list->v;
    if (v->type == SSTRING || v->type == SSYMBOL) {
      if (v->body.string != NULL) {
        free(v->body.string);
      }
    } else if (v->type == SEXPRESSION) {
      if (v->body.expression != NULL) {
        free(v->body.expression);
      }
    }
    free(v);
    l = value_list;
    value_list = value_list->next;
    free(l);
  }
}

value
mk_value(int type, char *string, int integer)
{
  value v = new_value();
  
  v->type = type;
  if (type == SINTEGER) {
    v->body.integer = integer;
  } else if (type == SSTRING || type == SSYMBOL) {
    v->body.string = strdup(string);
  } else {
    fprintf(stderr, "unknown type\n");
  }
  return v;
}

value
mk_expression(value e, ...)
{
  static value value_buffer[2000];
  int i = 0;
  value v = new_value();
  value ee = NULL;
  va_list ap;

  v->type = SEXPRESSION;
  va_start(ap, e);
  for (ee = e; ee != NULL; ee = va_arg(ap, value)) {
    value_buffer[i++] = ee;
  }
  va_end(ap);
  v->size = i;
  v->body.expression = malloc(i*sizeof(value*));
  memcpy(v->body.expression, value_buffer, i*sizeof(value));
  return v;
}

value
mk_expression0()
{
  int i = 0;
  value v = new_value();
  v->type = SEXPRESSION;
  v->size = i;
  return v;
}

value
mk_expression1(value e)
{
  int i = 1;
  value v = new_value();
  v->type = SEXPRESSION;
  v->size = i;
  v->body.expression = malloc(i*sizeof(value*));
  v->body.expression[0] = e;
  return v;
}

#define mk_list(label, ...) mk_expression(mk_symbol(label), __VA_ARGS__)

value
expression_from_to(value e, int from, int to)
{
  int i;
  value v = new_value();
  v->type= SEXPRESSION;
  v->size = to - from; 
  v->body.expression = malloc(sizeof(value*) * v->size);
  for (i = 0; from < to; i++, from++) {
    v->body.expression[i] = e->body.expression[from];
  }
  return v;
}
  
value
mk_string(char *string)
{
  return mk_value(SSTRING, string, 0);
}

value
mk_symbol(char *string)
{
  return mk_value(SSYMBOL, string, 0);
}

value
mk_integer(int v)
{
  return mk_value(SINTEGER, NULL, v);
}

int
digitValue(char v)
{
  if ('0' <= v && v <= '9') {
    return v - '0';
  }

  if ('A' <= v && v <= 'Z') {
    return v - 'A' + 10;
  }

  return 0;
}

value
expression_append(value a, value b)
{
  value v;
  if (a == NULL) {
    return b;
  }
  if (b == NULL) {
    return a;
  }
  v = new_value();
  v->type = a->type;
  if (!(a->type == SEXPRESSION && b->type == SEXPRESSION)) {
    print_value(a); fprintf(stderr, "\n");
    print_value(b); fprintf(stderr, "\n");
    fprintf(stderr, "error\n");
    exit(2);
  }
  v->size = a->size + b->size;
  v->body.expression = malloc(sizeof(value*) * v->size);
  memcpy(v->body.expression, a->body.expression, sizeof(value*) * a->size);
  memcpy(v->body.expression+a->size, b->body.expression, sizeof(value*) * b->size);
  return v;
}

value
expression_copyWith(value a, value b)
{
  value v;
  if (a == NULL) {
    return b;
  }
  if (b == NULL) {
    return a;
  }
  v = new_value();
  v->type = a->type;
  v->size = a->size + 1;
  if (a->type != SEXPRESSION) {
    fprintf(stderr, "a type%d\n", a->type);
    exit(1);
  }
  v->body.expression = malloc(sizeof(value*) * v->size);
  memcpy(v->body.expression, a->body.expression, sizeof(value*) * a->size);
  v->body.expression[a->size] = b;
  return v;
}

value
symbol_copyWith(value a, value b)
{
  value v = new_value();
  char *buf;
  
  if ((a->type != SSYMBOL && a->type != SSTRING) || (b->type != SSYMBOL && b->type != SSTRING)) {
    fprintf(stderr, "error\n");
    fprintf(stderr, "types %d, %d\n", a->type, b->type);
    exit(3);
  }
  v->type = SSYMBOL;
  buf = malloc(strlen(a->body.string) + strlen(b->body.string) + 1);
  strcpy(buf, a->body.string);
  strcat(buf, b->body.string);
  v->body.string = buf;
  return v;
}

/******************************************************************************
*  Encoder                                                                    *
*******************************************************************************/

/*char*
start(value tree)
{
  if (headIs(tree, 'methodDef')) {
     char *c = first(second(tree));
     char * meta = second(second(tree));
     if(strncmp(c, class_name_prefix, strlen(class_name_prefix)) == 0) {
       c = c + strlen(class_name_prefix);
       class_name = malloc(strlen(c) + strlen(meta) + 1)
    

  method1(class
*/


%}

start     = - (s:start-one {parse_result = expression_copyWith(parse_result, s);}) -

start-one = -
            ( c:stamp m:method - '! !' -		        {$$ = mk_list("methodDef", c, m, NULL);}
	    | class-definition
	    | init
	    | doit )


doit      = <(expression | -)> '!' -				{$$ = mk_list("doit", mk_string(yytext), NULL);}
init 	  = i:identifier 'initialize!' -			{$$ = mk_list("init", i, NULL);}
stamp	  = '!' r:new-empty-symbol s:identifier-name <(' class' | '')>
             {r = symbol_copyWith(r, s); r = symbol_copyWith(r, mk_symbol(yytext));} -
               'methodsFor:' - (!'!' .)* '!' -			{$$ = r;}

class-definition = p:identifier 'subclass: #' c:identifier 'instanceVariableNames: ' ivar:single-string
		     'classVariableNames: ' cvar:single-string - 'poolDictionaries: ' single-string
		     'category: ' single-string '!'
		   {$$ = mk_list("classDef", p, c, ivar, cvar, NULL);}

method = m:message-pattern t:temporaries primitive? l:method-block {$$ = mk_list("method", m, t, l, NULL);}

method-block = params:block-parameters temps:temporaries (body:expression-list | body:return-self)
		    {$$ = mk_list("block", params, temps, body, NULL);}

message-pattern = args:new-empty-expression name:new-empty-symbol
                   (k:keyword i:identifier
                     {args = expression_copyWith(args, i);
		      name = symbol_copyWith(name, k); })+
		  {$$ = mk_list("message", name, args, NULL);}
		| name:binary-selector arg:identifier {$$ = mk_list("message", name, mk_expression1(arg), NULL);}
		| name:unary-selector {$$ = mk_list("message", name, mk_expression0(), NULL);}

block       = lbrack v:block-default-nil rbrack {$$ = v;}

block-default-nil = params:block-parameters temps:temporaries (body:expression-list | body:variable-nil)
		    {$$ = mk_list("block", params, temps, body, NULL);}


block-parameters = params:new-empty-expression (b:block-parameter {params = expression_copyWith(params, b);})+ bar
		   {$$ = expression_append(mk_list("params", NULL), params);}
		 | {$$ = mk_expression1(mk_symbol("params"));}

block-parameter = ':' - identifier

temporaries = bar ids:new-empty-expression (id:identifier {ids = expression_copyWith(ids, id);})* bar { $$ = expression_append(mk_list("temps", NULL), ids);}
	    | {$$ = mk_list("temps", NULL);}

expression = v:variable assign u:expression			     { $$ = mk_list("assign", v, u, NULL);}
	   | s:maybe-cascade-head (c:cascade {s = expression_copyWith(s, c);})+ {$$ = s}
	   | message-send
	   | primary

expression-list = hat e:expression (dot | -)				{$$ = mk_list("return", e, NULL);}
	        | e:expression dot l:expression-list			{$$ = mk_list("sequence", e, l, NULL);}
	        | e:expression dot?					{$$ = e;}

maybe-cascade-head = s:message-send r:new-empty-expression
                     {$$ = expression_copyWith(expression_append(r, mk_list("cascade", s->body.expression[2], NULL)),
                           expression_copyWith(mk_list("cascadeSend", s->body.expression[1], NULL), expression_from_to(s, 3, s->size)))}

variable = i:identifier 					     { $$ = mk_list("variable", i, NULL);}

pseudo-variable = <('self' | 'super')> - 			     { $$ = mk_string(yytext);}

variable-nil = {$$ = mk_list("variable", mk_string("nil"), NULL);}
return-self  = {$$ = mk_list("return", mk_string("self"), NULL);}

integer = s:new-integer b:new-integer ret:new-integer
          ('-' {s->body.integer = -1;} | {s->body.integer = 1;})
          (<([0-9][0-9] | [0-9])> 'r' {b->body.integer = atoi(yytext);} | - {b->body.integer = 10;})
          {ret->body.integer = 0}
	  (<[0-9A-Z]>
             {ret->body.integer = ret->body.integer * b->body.integer + digitValue(yytext[0]);})+ - 
	  {$$ = mk_list("integer", mk_integer(ret->body.integer * s->body.integer), NULL);}
new-integer = {$$ = mk_integer(0);}

single-string = "\'" <(!"\'" . | "\'\'")*> "\'"	-					{$$ = mk_string(yytext);}

selector = keyword-selector | unary-selector | binary-selector

unary-selector = <identifier-name> !':' - 					{$$ = mk_symbol(yytext); }
binary-selector = <binary-character+> -	 					{$$ = mk_symbol(yytext); }
keyword-selector = ret:new-empty-symbol (k:keyword-name {ret = symbol_copyWith(ret, k);})+ - {$$ = ret;}
binary-character = [-+/\\*~<>=@%|&?,`]
new-empty-symbol = {$$ = mk_symbol("");}
new-empty-expression = {$$ = mk_expression0();}

keyword      = k:keyword-name -						      {$$ = k;}
keyword-name = <(identifier-name ':')>	   	     		 	      {$$ = mk_string(yytext);}

message-send = keyword-send | binary-send | unary-send

keyword-send = r:binary-argument args:new-empty-expression name:new-empty-symbol
	       (s:keyword a:binary-argument {name = symbol_copyWith(name, s); args = expression_copyWith(args, a); })+
               {$$ = expression_append(mk_list("send", name, r, NULL), args); }

binary-send = r:unary-argument
	        (s:binary-selector a:unary-argument
		   {r = mk_list("send", s, r, a, NULL);})+
              {$$ = r;}

binary-argument = binary-send | unary-argument
unary-argument = unary-send | primary
unary-send    = r:primary (s:unary-selector {r = mk_list("send", s, r, NULL);})+ {$$ = r;}

cascade       = semicolon (s:cascade-unary | s:cascade-binary | s:cascade-keyword) {$$ = expression_append(mk_list("cascadeSend", NULL), s);}

cascade-unary  = s:unary-selector {$$ = mk_expression1(s);}
cascade-binary = s:binary-selector a:binary-argument {$$ = mk_expression(s, a, NULL);}
cascade-keyword = args:new-empty-expression name:new-empty-symbol
		  (s:keyword a:binary-argument {name = symbol_copyWith(name, s); args = expression_copyWith(args, a); })+
		  {$$ = expression_append(mk_expression1(name), args);}

array-literal = '#' literal-array
literal-array = lparen r:new-empty-expression {r = expression_copyWith(r, mk_symbol("array"));} (a:array-element {r = expression_copyWith(r, a);})* rparen {$$ = r;}
array-element = literal | s:selector {$$ = mk_list("symbol", s, NULL);} | literal-array

brace = lbrace e:expression-list rbrace {$$ = mk_list("brace", e, NULL);}

primary =  (lparen e:expression rparen {$$ = e;}) | block | brace | variable | pseudo-variable | literal

literal = single-string | integer | character-literal | symbol-literal | array-literal

character-literal = '$' <.> - {$$ = mk_list("character", mk_string(yytext), NULL);}
symbol-literal = '#' (s:selector | s:single-string) {$$ = mk_list("symbol", s, NULL);}

primitive =  langle <(!rangle .)*> rangle {$$ = mk_list("primitive", mk_string(yytext), NULL);}

assign  = ('_' | ':=') -

lbrace = '{' -
rbrace = '}' -

langle = '<' -
rangle = '>' -

lparen = '(' -
rparen = ')' -

lbrack = '[' -
rbrack = ']' -

bar    = '|' -
hat    = '^' -

semicolon = ';' - 
dot = '.' -

identifier-character = [a-zA-Z]
identifier-rest = [a-zA-Z0-9]
identifier-name = <identifier-character identifier-rest*>			     {$$ = mk_string(yytext);}

identifier = i:identifier-name -						     {$$ = i;}

comment = '\"' <(!'\"' .)*> '\"'						     {$$ = mk_string(yytext);}

-     = ([ \t\n\r] | comment)*

%%

void
validate_value(value a)
{
  int i;
  if (a->type == SEXPRESSION) {
    for (i = 0; i < a->size; i++) {
      if (&(a->body.expression[i]) - a->body.expression > 1000) {
        fprintf(stderr, "wrong entry\n");
        exit(1);
      }
      validate_value(a->body.expression[i]);
    }
  }
  else if (a->type == SINTEGER) {
    if (a->size != 0) {
      fprintf(stderr, "integer corrupted\n");
      exit(8);
    }
  } else if (a->type == SSTRING || a->type == SSYMBOL) {
    for (i = 0; i < strlen(a->body.string); i++) {
      if (a->body.string[i] < 0) {
        fprintf(stderr, "string corrupted\n");
        fprintf(stderr, "%d %d %d %s\n", i, strlen(a->body.string), a->serial, a->body.string);
        exit(8);
      }
    }
  } else {
    fprintf(stderr, "really corrupted\n");
    fprintf(stderr, "%p, %d\n", a, a->type);
    exit(8);
  }
}

void
print_value(value a)
{
/*  fprintf(stderr, "yyval - yyvals = %d\n", yyval - yyvals); */
  if (a->type == SEXPRESSION) {
    int i = 0;
    fprintf(stderr, "#(");
    for (i = 0; i < a->size; i++) {
      print_value(a->body.expression[i]);
      if (i < a->size - 1) fprintf(stderr, " ");
    }
    fprintf(stderr, ")");
  }
  else if (a->type == SINTEGER) {
    fprintf(stderr, "%d", a->body.integer);
  } else if (a->type == SSTRING) {
    fprintf(stderr, "\'%s\'", a->body.string);
  } else if (a->type == SSYMBOL) {
    fprintf(stderr, "#%s", a->body.string);
  }
}



#ifndef TEST
int
main()
{
  GREG g;
  memset(&g, 0, sizeof(GREG));
  myfile = fopen("c:/Users/ohshima/Documents/Visual Studio 2008/Projects/SqParser/sq/test", "r");
  while (yyparse(&g)) {
    if (parse_result) {print_value(parse_result); parse_result = NULL;}
  }
  fclose(myfile);
  return 0;
}

#else

int
main()
{
  parse_result = mk_expression0();
  parse_result = foo(parse_result, 3);
  print_value(parse_result);
  return 0;
}

#endif
