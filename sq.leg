%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

FILE *myfile = NULL;

/*#define YY_INPUT(buf, result, max_size)        \
                  {                                              \
                    int yyc= fgetc(myfile);                          \
                    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1); \
                  }
*/

//#define YY_DEBUG

typedef struct _value {
  int type;
  int size;
  union {
    char *string;
    int integer;
    struct _value **expression;
  } body;
} *value;

#define YYSTYPE value

#define SNULL 0
#define SINTEGER 1
#define SSTRING 2
#define SSYMBOL 3
#define SEXPRESSION 4

void print_value(value a);

value
mk_value(int type, char *string, int integer)
{
  value v = malloc(sizeof(struct _value));
  v->type = type;
  if (type == SINTEGER) {
    v->size = 0;
    v->body.integer = integer;
  } else if (type == SSTRING || type == SSYMBOL) {
    v->body.string = strdup(string);
    v->size = strlen(string);
  }
  return v;
}

value
mk_expression(value e, ...)
{
  static value value_buffer[100];
  va_list ap;
  int i = 0;
  value v = malloc(sizeof(struct _value));
  v->type = SEXPRESSION;
  value ee;

  va_start(ap, e);
  for (ee = e; ee != NULL; ee = va_arg(ap, value)) {
    value_buffer[i++] = ee;
  }
  va_end(ap);
  v->size = i;
  v->body.expression = malloc(i*sizeof(value));
  memcpy(v->body.expression, value_buffer, i*sizeof(value));
  return v;
}
  
value
mk_string(char *string)
{
  return mk_value(SSTRING, string, 0);
}

value
mk_symbol(char *string)
{
  return mk_value(SSYMBOL, string, 0);
}

value
mk_empty_symbol()
{
  char *m = malloc(1000);
  value v = mk_symbol("");
  memset(m, 0, 1000);
  v->body.string= m;
  return v;
}

value
mk_integer(int v)
{
  return mk_value(SINTEGER, NULL, v);
}

int
digitValue(char v)
{
  if ('0' <= v && v <= '9') {
    return v - '0';
  }

  if ('A' <= v && v <= 'Z') {
    return v - 'A' + 10;
  }

  return 0;
}

value
mk_null()
{
  return mk_value(SNULL, NULL, 0);
}

value
expression_append(value a, value b)
{
  value *exp = malloc(sizeof(value*) * (a->size + b->size));
  memcpy(exp, a->body.expression, sizeof(value*) * a->size);
  memcpy(exp+a->size, b->body.expression, sizeof(value*) * b->size);
  a->size += b->size;
  return a;
}

void
print_value(value a)
{
  if (a->type == SEXPRESSION) {
    int i;
    printf("(");
    for (i = 0; i < a->size; i++) {
      print_value(a->body.expression[i]);
      if (i < a->size - 1) printf(" ");
    }
    printf(")");
  }
  else if (a->type == SINTEGER) {
    printf("%d", a->body.integer);
  } else if (a->type == SSTRING) {
    printf("\'%s\'", a->body.string);
  } else if (a->type == SSYMBOL) {
    printf("#%s", a->body.string);
  }
}

%}

start = - s:expression						     { print_value(s); printf("\n");}

expression = v:variable assign u:expression			     { $$ = mk_expression(mk_symbol("assign"), v, u, NULL);}
	   | message-send
	   | primary

variable = i:identifier 					     { $$ = mk_expression(mk_symbol("variable"), i, NULL);}

pseudo-variable = <('self' | 'super')> - 			     { $$ = mk_string(yytext);}

integer = s:new-integer b:new-integer ret:new-integer
          ('-' {s->body.integer = -1;} | {s->body.integer = 1;})
          (<([0-9][0-9] | [0-9])> 'r' {b->body.integer = atoi(yytext);} | - {b->body.integer = 10;})
          {ret->body.integer = 0}
	  (<[0-9A-Z]>
             {ret->body.integer = ret->body.integer * b->body.integer + digitValue(yytext[0]);})+ - 
	  {$$ = mk_integer(ret->body.integer * s->body.integer);}
new-integer = {$$ = mk_integer(0);}

single-string = "\'" <(!"\'" .)*> "\'"						{$$ = mk_string(yytext);}

selector = keyword-selector | unary-selector | binary-selector

unary-selector = name:identifier-name !':' - 					{$$ = mk_symbol(name->body.string);}
binary-selector = <binary-character*>	 					{$$ = mk_symbol(yytext);}
keyword-selector = ret:new-empty-symbol (k:keyword-name {strcat(ret->body.string, k->body.string);})+ {ret->size = strlen(ret->body.string); $$ = ret;}
binary-character = [-+/\\*~<>=@%|&?,`]
new-empty-symbol = {$$ = mk_empty_symbol();}
new-empty-expression = {$$ = mk_expression(NULL);}

keyword      = k:keyword-name -						      {$$ = k;}
keyword-name = <(identifier-name ':')>	   	     		 	      {$$ = mk_string(yytext);}

message-send = keyword-send | binary-send | unary-send
keyword-send = r:binary-argument args:new-empty-expression name:new-empty-symbol
	       (s:keyword a:binary-argument {expression_append(name, s); expression_append(args, a); })+
               {$$ = expression_append(mk_expression(mk_symbol("send"), name, r, NULL), args); }
binary-send = r:unary-argument (s:binary-selector a:unary-argument {r = mk_expression(mk_symbol("send"), s, r, a, NULL);})+ {$$ = r;}
binary-argument = binary-send | unary-argument
unary-argument = unary-send | primary
unary-send    = r:primary (s:unary-selector {r = mk_expression(mk_symbol("send"), s, r, NULL);})+ {$$ = r;}

primary = variable | pseudo-variable | literal | (lparen e:expression rparen {$$ = e})

literal = single-string | integer

lbrace = '{' -
rbrace = '}' -

langle = '<' -
rangle = '>' -

lparen = '(' -
rparen = ')' -

lbrack = '[' -
rbrack = ']' -

bar    = '|' -
hat    = '^' -

assign  = ('_' | ':=') -

identifier-character = [a-zA-Z]
identifier-rest = [a-zA-Z0-9]
identifier-name = <identifier-character identifier-rest*>			     {$$ = mk_string(yytext);}

identifier = i:identifier-name -						     {$$ = i;}

comment = '\"' <(!'\"' .)*> '\"'						     {$$ = mk_string(yytext);}

-     = ([ \t\n\r] | comment)*

%%

int main()
{
  /*myfile = fopen("test", "r"); */
  while (yyparse())
    ; 
  /* fclose(myfile); */
  return 0;
}
